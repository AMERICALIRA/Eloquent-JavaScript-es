:chap_num: 3
:prev_link: 02_program_structure
:next_link: 04_data

= Funciones =

[chapterquote="true"]
[quote, Donald Knuth]
____
La gente piensa que las ciencias de la computación son el
arte de los genios pero la realidad es lo contrario, es sólo un
montón de gente haciendo cosas que se construyen sobre otras,
como una pared de piedras muy pequeñas.
____

(((Knuth+++,+++ Donald)))(((función)))(((estructura del código)))Has visto
valores función, como `alert`, y cómo llamarlos. Las funciones son el pan de
cada día en la programación en JavaScript. El concepto de de envolver
una porción del programa en un valor(variable) tiene muchos usos.
Es una herramienta para estructurar programas más grandes, para reducir
la repetición, para asociar nombres con subprogramas, y para separar
estos programas de los demás.

(((lenguaje humano)))La aplicación más obvia de las funciones es la de
definir un nuevo ((vocabulario)). Crear nuevas palabras en la prosa regular en
lenguaje humano es usualmente un mal estilo. Pero en programación, es
indispensable.

(((abstracción)))Un adulto promedio tiene unas 20,000 palabras en su
vocabulario. Pocos lenguajes de programación tienen 20,000 comandos
incorporados. Y el vocabulario que _está_ disponible tiende a ser 
definido de forma más precisa, así que es menos flexible
que en un lenguaje humano. En consecuencia, usualmente _tenemos_
que añadir algo de nuestro propio vocabulario para evitar repetirnos
demasiado.

== Definiendo una función ==

(((cuadrado)))(((función,definición)))Una definición de una función
es sólo una definición regular de una ((variable)) cuando ocurre que el 
valor dado a la variable es una función. Por ejemplo, el siguiente código
define la variable `cuadrado` para referirse a la función que produce
el cuadrado de un número dado:

[source,javascript]
----
var cuadrado = function(x) {
  return x * x;
};

console.log(cuadrado(12));
// → 144
----

indexsee:[llaves]
(((llaves)))(((bloque)))(((sintaxis)))(((palabra reservada
function)))(((función, cuerpo)))(((función,como valor)))Una función es
creada por una expresión que empieza con la palbra reservada `function`.
Las funciones tienen un conjunto de _((parametros))_ (en este caso
sólo `x`) y un _cuerpo_, que contiene las sentencias que serán ejecutadas
cuando la función sea llamada. El cuerpo de la función tiene que estar
siempre encerrado en llaves, incluso cuando consista de una sola
((instrucción)) (como en el ejemplo previo).

(((ejemplo de la potencia)))Una función puede tener varios parámetros
o puede no tener ninguno. En el siguiente ejemplo `hazRuido` no tiene
parámetros, mientras que `potencia` tiene dos:

[source,javascript]
----
var hazRuido = function() {
  console.log("Pling!");
};

hazRuido();
// → Pling!

var potencia = function(base, exponente) {
  var resultado = 1;
  for (var cuenta = 0; cuenta < exponente; cuenta++)
    resultado *= base;
  return resultado;
};

console.log(potencia(2, 10));
// → 1024
----

(((valor de retorno)))(((palabra reservada return)))(((undefined)))Algunas
funciones producen un valor, como `potencia` y `cuadrado`, y algunas no,
como `hazRuido`, la cuál produce sólo un ((efecto secundario)). Una sentencia
`return` determina el valor que una función regresa. Cuando el control
pasa a esta sentencia, inmediatamente salta fuera de la función actual
y pasa el valor retornado a la código que llamó la función. La palabra 
reservada `return` sin una expresión después de ella hará que la función
devuelva `undefined`.

== Parámetros y ámbitos ==

(((función, aplicación)))(((variable,de parametro)))Los
((parametro))s para una función se comportan como variables normales,
pero su valor inicial esta dado por _quien llama_ a la función, no por
el código mismo de la función. 

(((función,ámbito)))(((ámbito)))(((variable local)))Un propiedad
importante de las funciones es que las varibales creades dentro de ellas,
incluyendo sus parámetros, son _locales_ para la función. Este significa,
por ejemplo, que la varibale `resultado` en el ejemplo `potencia` será
creada de nuvo cada vez que la función es llamada, y estas instancias
separadas no interfieren entre ellas.

indexsee:[ámbito superior,ámbito global]
(((palabra reservada var)))(((ámbito global)))(((variable,global)))Esta 
"localidad" de las variables aplica sólo a los parámetros y variables
declaradas con la palabra reservada `var` dentro del cuerpo de la función.
Las variables declaradas duera de cualquier función son llamadas _globales_,
porque son visibles a través de todo el programa. Es posible acceder a
estas variables desde dentro de una función, mientras no hayas declarado una
variable local con el mismo nombre.

(((variable,asignación)))El siguiente código demuestra eso. Define y llama 
dos funciones que asignan un valor a la variable `x`. La primera declara
la variable como local y de esta manera cambia únicamente la variable que
creó. La segunda no declara `x` localmente, así que la `x` dentro de ella
hace referencia a la `x` definida al principio del ejemplo.

[source,javascript]
----
var x = "fuera";

var f1 = function() {
  var x = "dentro de f1";
};
f1();
console.log(x);
// → fuera

var f2 = function() {
  x = "dentro de f2";
};
f2();
console.log(x);
// → dentro de f2
----

(((variable,nombrado)))(((ámbito)))(((ámbito global)))(((code,estructura
de)))Este comportamiento ayuda a prevenir interferencia accidental entre
las funciones. Si todas las variables fueran compartidas por el programa
entero, sería muy difícil asegurarse de que algún nombre no fue usado para
dos propósitos diferentes. Y si _reusaste_ un nombre de variable, podrías
ver efectos extraños de código no relacionado causando problemas en el valor
de tu variable. Al tratar tus variables locales a la función, el lenguaje
hace posible leer y entender las funciones como un pequeños universos,
sin tener que preocuparse de todo el código a la vez.

[[scoping]]
== Ámbitos Anidados ==

(((anidado,de funciones)))(((anidado,de
ámbitos)))(((ámbito)))(((función interna)))(((definición léxica
de ámbito)))JavaScript distingue nos solo entre variables _globales_ y _locales_
Las funciones pueden ser creadas dentro de otras funciones, 
produciendo distindos grados de                                   localidad.

(((ejemplo paisaje)))Por ejemplo, esta función sin sentido, tiene dos
funciones dentro de ella:

[source,javascript]
----
var paisaje = function() {
  var resultado = "";
  var meseta = function(tamano) {
    for (var cuenta = 0; cuenta < size; cuenta++)
      resultado += "_";
  };
  var montana = function(tamano) {
    result += "/";
    for (var cuenta = 0; cuenta < size; cuenta++)
      resultado += "'";
    resultado += "\\";
  };
 
  meseta(3);
  montana(4);
  meseta(6);
  montana(1);
  meseta(1);
  return resultado;
};

console.log(landscape());
// → ___/''''\______/'\_
----

(((función,ámbito)))(((ámbito)))Las funciones `meseta` y `montana`
pueden "ver" la variable llamada `resultado`, debido a que están 
dentro de la función que la define. Pero no pueden ver la variable
`cuenta` entre ellas, porque están definidas fuera del ámbito de la otra.
El entorno fuera de la función `paisaje` no puede acceder a ninguna de
las variables definidas dentro de `paisaje`.

En pocas palabras, cada ámbito local también puede ver los ámbitos
locales que lo contienen. El conjunto de variables visible dentro de
la función es determinado por el lugar de la función en el texto del
programa. Todas las variables de los bloques que _envuelven_ una
la definición de una función son visibles para ella, esto es, en todos
los cuerpos de las funciones que la envuelven y las correspondientes
al nivel superior(ámbito global). Este manera de resolver la visibilidad
de las variables es llamada _((definición léxica de ámbito))_(lexical scoping).

((({} (bloque))))Las personas que tienen experiencia con otros lenguajes
de programción podrían esperar que cualquier bloque entre llaves produzca 
un nuevo entorno local. Pero en JavaScript, las funciones son lo único
que crea un nuevo ámbito. Pero puedes usar bloques independientes.

[source,javascript]
----
var algo = 1;
{
  var algo = 2;
  // Haz algo con la variable...
}
// Fuera del bloque...
----

Pero la variable `algo` dentro del bloque se refiere a la misma variable
que la que está fuera del bloque. De hecho, aunque bloques como este
son permitidos, sólo son útiles para agrupar el cuerpo de las sentencias
`if` o de los bucles.

(((palabra clave let)))(((ECMAScript 6)))Si esto te parece raro, no eres
el único. La próxima versión de  JavaScript introducirá una palabra
reservada `let`, que trabaja como `var` pero crea una variable que es
local para el _bloque_ en el que está, no para la función.

== Funciones como valores ==

(((funciones,como valor)))Las ((variables)) de función normalmente actúan
como nombres para una parte específica del programa. Esa variables es
definida una vez y nunca cambiada. Esto hace fácil empezar a confundir 
la función con su nombre.

(((vriable,asignación)))Pero son diferentes entre sí. Un valor función
puede hacer todo los que los otros valores pueden hacer; lo puedes usar
en ((expresiones)) arbitrarias, no sólo llamarlos. Es posible guardar la
función en un nuevo lugar, pasar como argumento a otra función, etc. De
manera parecida, la variable que contiene una función sigue siendo una variable
normal a la que se le puede asignar otro valor, como sigue:
// test: no

[source,javascript]
----
var lanzarMisiles = function(valor) {
  sistemaDeMisiles.lanzar("ahora");
};
if (modoSeguro)
  lanzarMisiles = function(valor) {/* No hacer nada. */};
----

(((función,orden superior)))En
link:05_higher_order.html#higher_order[Capítulo 5], hablaremos de las
maravillosas cosas que puedes hacer al pasar valores función a otras funciones.

== Notación de Declaración ==

(((sintaxis)))(((ejemplo del cuadrado)))(((palabra clave
function)))(((función,definición)))(((función,declaración)))Existe una
forma más corta de decir “++var square = function…++”. La palabra reservada
`function` puede ser usada al principio de una sentencia, como sigue:

[source,javascript]
----
function cuadrado(x) {
  return x * x;
}
----

(((futuro)))(((order de ejecución)))Esta es una _declaración_ de función.
La expresión define la variable `cuadrado` y la apunta a la función
dada. Hasta aquí todo bien. sin embargo, hay una pequeña sutileza con
esta forma de definición.

[source,javascript]
----
console.log("El futuro dice: ", futuro());

function future() {
  return "Seguimos sin tener carros voladores.";
}
----

Este código funciona aunque la función está definida _debajo_ del 
código que la usa. Esto es debido a que las declaraciones de función
no toman parte en el flujo de control regular de arriba hacia abajo.
Son movidas conceptualmente a la parte superior de su ámbito y pueden
ser usadas por todo el código en ese ámbito. Esto es útil algunas veces
porque nos da la libertad de organizar el código de una manera parezca
significativa sin preocuparnos por definir todas las funciones antes de
su primer uso.

(((función,declaración)))¿Qué pasa cuando pones una declaración
de función dentro de un bloque condicional (`if`) o dentro de un bucle?
Bueno, mejor no lo hagas. Diferentes plataformas de JavaScript en 
diferentes navegadores hacen diferentes cosas tradicionalmente en esa
situación, y el último ((estándar)) de hecho lo prohibe. Si quieres que
tus programas sean consistentes, usa las sentencia de declaración de función
en el bloque más externo de tu función o programa.

[source,javascript]
----
function ejemplo() {
  function a() {} // Bien
  if (alguna_condicion) {
    function b() {} // ¡Peligro!
  }
}
----

[[stack]]
== La pila de llamadas ==

indexsee:[pila,pila de llamadas]
(((pila de llamadas)))(((función,aplicación))) Será útil mirar más de
cerca la forma en que el control se mueve a través de las funciones.
Aquí hay un simple programa que hace unas cuantas llamadas a funciones.

[source,javascript]
----
function saluda(a_quien) {
  console.log("Hola " + a_quien);
}
saluda("Harry");
console.log("Adiós");
----

(((flujo de control)))(((order de ejecución)))(((console.log))Una ejecución
de este programa va más o menos así: la llamada a `saluda` causa que el control
pase al inicio de esa función (línea 2). Esta llama a `control.log` (una función
incluída en los navegadores), que toma el control, hace su trabajo, y devuelve
el control a la línea 2. Después, se alcanza el dinal de la función `saluda`, así
que se regresa al lugar en dónde se llamó, en la línea 4. La línea siguiente llama
a `console.log` otra vez.

Podemos mostrar el flujo de control esquemáticamente así:

----
raíz
   saluda
        console.log
   saluda
raíz
   console.log
raíz
----

(((palabra reservada return)))(((memoria)))Debido a que una función tiene que 
saltar de regreso al lugar en que fue llamada cuando termine, la computadora
debe recordar el contexto en el que fue llamada. En un caso, `console.log` tiene
que regresar a la función `saluda`. En el otro caso salta al final del programa.

El lugar en el que la computadora guarda este context es la _((pila de llamadas))_.
Cada vez que una función es llamada, el contexto actual es puesto en la parte superior
de esta pila. Cuando la función retorne, remueve el contexto superior de la "pila" y
lo usa para continuar la ejecución.

(((loo infinito)))(((desbordamiento de la pila)))(((recursión)))Guardar esta pila requiere
espacio en la memoria de la coputadora. Cuando la pila se hace demasiado grande
la computadora mostrará un error parecido a "out of stack space" (sin espacio en la
en la pila) o "too much recursion" (demasiada recursión). El siguiente código lo ilustra
al preguntarle algo realmente difícil a la computadora, lo que causa un ir y venir
infinito entre funciones. Más bien, _sería_ infinito, si la computadora 
tuviera una pila infinita. Como son las cosas, nos quedaremos sin espacio,
o "volaremos la pila".
// test: no

[source,javascript]
----
function gallina() {
  return huevo();
}
function huevo() {
  return gallina();
}
console.log(gallina() + " fue primero");
// → ??
----

== Argumentos Opcionales ==

(((argumento)))(((función,aplicación)))El siguiente código es permitido y se ejecuta sin
ningún problema:

[source,javascript]
----
alert("Hola", "Buenas Noches", "¿Cómo estás?");
----

(((función alert)))La función `alert` oficialmente acepta sólo un argumento.
Aún así, cuando la llamas como aquí, no se queja. Simplemente ignora los otros
argumentos y te muestra "Hola".

(((undefined)))(((parámetros)))JavaScript es extremadamente abierta de mente
acerca del número de argumentos que le pasas a una función. Sí le pasas demasiados,
loa argumentos extra son ignorados. Si le pasas muy pocos, los parámetros quie faltan
simplemente son asignados a `undefined`.

El lado malo de esto es que es posbible/probable, casi seguro que le pasarás
accidentalmente un número incorrecto de argumentos a las funciones y nadie te
avisará.

[[potencia]]
(((ejemplo de la potencia)))(((argumentos opcionales))) El lado bueno de este
comportamiento es que puede ser usado para tener una función que 
tome parámetros "opcionales". Por ejemplo, la siguiente versión de
`potencia` puede ser llamada con dos argumentos o uno solo, caso en el que
el exponente se asume como dos, y la función se comporta como `cuadrado`.

// test: wrap

[source,javascript]
----
function potencia(base, exponente) {
  if (exponente == undefined)
    exponente = 2;
  var resultado = 1;
  for (var cuenta = 0; cuenta < exponente; cuenta++)
    resultado *= base;
  return resultado;
}

console.log(potencia(4));
// → 16
console.log(potencia(4, 3));
// → 64
----

(((console.log)))En el link:04_data.html#arguments_object[próximo
capítulo], veremos una forma en la que el cuerpo de una función puede 
obetener la lista exacta de argumentos que se le pasaron. Esto es útil
porque permite a una función aceptar un número indeterminado de argumentos.
Por ejemplo, `console.log` hace uso de esto: imprime todos los valores que
se le pasaron.

[source,javascript]
----
console.log("R", 2, "D", 2);
// → R 2 D 2
----

== Closure ==

(((pila de llamadas)))(((variable local)))(((función,como
valor)))(((closure)))(((ámbito))) La habilidad de tratar Funciones
como valores, combinada con el hecho de que las varibles locales son
"re-creadas" cada vez que una función es llamada, saca a la luz
una pregunta interesante. ¿Qué pasa con las variables locales 
cuando la función que las creó ya no está activa?

El siguiente código muestra un ejemplo de esto. Define una funnción,
`envuelveValor`, que crea una variable local. Después devuelve una 
función que accede y devuelve esta variable local.

[source,javascript]
----
function envuelveValor(n) {
  var variableLocal = n;
  return function() { return variableLocal; };
}

var envoltura1 = envuelveValor(1);
var envoltura2 = envuelveValor(2);
console.log(envoltura11());
// → 1
console.log(envoltura2());
// → 2
----

Esto está permitido y funciona como esperarías; la variable todavía puede
leerse. De hecho, múltiples instancias de las variables pueden existir
al mismo tiempo, lo que es otra buena ilustración del concepto de que las
variables locales son re-creadas realmente para cada llamada; diferentes
llamadas no pueden afectar otras variables locales.

Esta característica -ser capaces de hacer referencia a una instancia 
local de varables en un función que las encierra- se llama '_closure_'.
Una función que "encapsula" algunas variables locales es llamada _una_
closure. Este comportamiento no sólo te libera de preocuparte de los
tiempos de vida de las variables, además permite algunos usos creativos
de las funciones.

(((función multiplicador))) Con un pequeño cambio, podemos podemos hacer
del ejemplo anterior funciones que multiplicquen por un número arbitrario.

[source,javascript]
----
function multiplicador(factor) {
  return function(numero) {
    return numero * factor;
  };
}

var doble = multiplicador(2);
console.log(doble(5));
// → 10
----
(((variable, desde parámetros))) La variable explícita `variableLocal` de la
función `envuelveValor` en el ejemplo previo no es necesaria porque un
parámetro en sí mismo es una variable local.

(((función, modelo de)))Concebir los parámetros de esta forma
requiere algo de práctica. Un buen modelo mental es pensar en la
palabra clave `function` como si "congelara" el código que está dentro de
ella en un paquete(el valor función). Así, cuando leas `return function(...){...}`,
piensa en que esto regresa un acceso a un conjunto de cálculos, congelados
para uso posterior.

En el ejemplo, `multiplicador` regresa un pedazo congelado de código que
se guarda en la variable `doble`. La última línea entonces llama el valor 
guardado en esta variable, haciendo que el código congelado (`return numero * factor;`)
se active. Este todavía tiene acceso a la variable `factor` de la llamada a 
`multiplicador` que lo creó, y además obtiene acceso al argumento que se pasa
cuando se activa el código, 5, a través de su parámetro `numero`.

== Recursión ==

(((ejemplo de la potencia)))(((desbordamiento de 
pila)))(((recursión)))(((función,aplicación)))Es perfectamente correcto que 
una función se llame a sí misma, mientras tenga cuidado de no desbordar la pila.
Una función que se llama a sí misma se llama _recursiva_. La recursión permite
que algunas funciones se escriban con un estilo diferente. Tomemos por ejemplo,
esta implementación alternativa de `potencia`:


// test: wrap

[source,javascript]
----
function potencia(base, exponente) {
  if (exponente == 0)
    return 1;
  else
    return base * potencia(base, exponente - 1);
}

console.log(potencia(2, 3));
// → 8
----

(((bucle)))(((legibilidad)))(((matemáticas))) Esto es más cercano
al modo en que los matemáticos definen la potenciación y describe
el concepto de un modo más elegante que la variante que lo hace con bucles.
La función se llama a sí misma varias veces con diferentes argumentos 
para conseguir la multiplicación repetida.

(((función, applicación)))(((eficiencia)))Pero esta implementación tiene
un problema importante: en implementaciones típicas de JavaScript, es
cerca de 10 veces más lenta que la versión con bucles. Correr a través
de un siple bucle es más barato que llamar a una función muchas veces.

(((optimización)))El dilema de velocidad contra ((elegancia)) es interesante.
Puedes verlo como un continuum entre amigabilidad-humano y amigabilidad-máquina.
Casi cualquier programa puede hacerse más rápido haciéndolo más grande
y convolucionado. El programador debe de decidir el balance apropiado.

En el caso de la función link:03_functions.html#potencia[anterior] `potencia`
la poco elegante versión(iterativa) es aún bastante simple y fácil de leer.
No tiene mucho sentido reemplazarla con la versión recursiva. A menudo,
sin embargo, un programa tiene conceptos tan complejos que sacrificar
un poco de eficiencia para hacer el programa más claro se vuelve una
opción atractiva.

(((profiling))) La regla básica, que ha sido repetida por muchos programadores
y con la cuál concuerdo de todo corazón, es no preocuparse por
la eficiencia hasta que estés seguro que el programa es demasiado lento.
Si lo es, busca las partes que están abarcando la mayoría del tiempo
y empieza a cambiar elegancia por eficiencia en esas partes.

Por supuesto, esta regla no significa que debas ignorar el rendimiento
completamente. En muchos casos, como en la función `potencia`,
no se gana demasiada simplicidad de la solución "elegante". Y algunas
veces un programador experimentado puede inmediatamente que un
soulución simple nunca va a ser lo suficientemente rápida.

(((optimización prematura)))La razón por la que estoy hablando tanto
de esto es que muchos programadores novatos se enfocan fanáticamente
en la eficiencia, incluso en los detalles más pequeños. El resultado
son programas más grandes, más complicados y a menudo menos correctos,
que toman más tiempo en escribirse que sus equivalentes más sencillos
y que generalmente corren solo un poco más rápido.

(((recursión ramificada)))Pero la recursión no es siempre sólo
una alternativa menos eficiente a los bucles. Alguos problemas son
mucho más fáciles de resolver con recursión que con bucles. La mayoría
de estos son problemas que requieren explorar o procesar varias "ramas",
cada una de las cuáles se puede ramificar otra vez.


[[rompecabezas_recursivo]]

(((recursión)))(((ejemplo del rompecabezas numéricos)))Considera el siguente
rompecabezas: empezando por el número 1 y añadiendo repetidamente 5 o
multiplicándolo por 3, un número infinito de nuevos números puede ser producido.
¿Cómo escribirías una función que, dado un número, trate de encontrar una 
secuencia de sumas y multipliclaciones que producen ese número?
Por ejemplo, el número 13 puede ser producido al multiplicar por 3 primero
y después sumar 5 dos veces, mientras que el número 15 no puede ser producido.

Aquí hay una solución recursiva:

[source,javascript]
----
function encontrarSolucion(objetivo) {
  function encontrar(inicio, historia) {
    if (inicio == objetivo)
      return historia;
    else if (inicio > objetivo)
      return null;
    else
      return encontrar(inicio + 5, "(" + historia + " + 5)") ||
             encontrar(inicio * 3, "(" + historia + " * 3)");
  }
  return encontrar(1, "1");
}

console.log(encontrarSolucion(24));
// → (((1 * 3) + 5) * 3)
----

Nota que este programa no encuentra necesariamente la ruta
_más corta_ de operaciones. Se satisface cuando cuentre cualquier sequencia.

No necesariamente espero que veas como este trabaja esto inmediatamente. Pero
trabajemos en eso, porque es un gran ejercicio en el pensamiento recursivo.

La función interna `encontrar` hace la recursividad. Toma dos 
((argumento))s – el número actual y una cadena que registra como
hemos alcanzado el número – y regresa o una cadena que muestra como
llegar al objetivo o `null`.

(((null)))(((operador ||)))(((evaluación de corto circuito))) Para hacer esto
la función realiza una de tres acciones. Si el número actual es el
número objetivo, entonces la historia actual es una forma de alcanzar 
este objetivo, así que siemplemente es devuelta. Si el número actual 
es mayot que el número objetivo, no tiene sentido seguir haciendo más 
exploraciones porque tanto sumar como multiplicar sólo hará mayor el número.
Y finalmente, si estamos todavía debajo del objetivo la función prueba
los dos caminos posibles que empiezan con el número actual llamándose dos
veces a sí misma, una vez por cada uno de los pasos permitos. Si la 
primera llamada regresa cualquier cosa que no sea `null`, se devuelve como
resultado. De otra forma, la segunda opción es la que se devuelve, independientemente
de si produce una cadena o `null`.

(((call stack)))To better understand how this function produces the
effect we're looking for, let's look at all the calls to `find` that
are made when searching for a solution for the number 13.

----
find(1, "1")
  find(6, "(1 + 5)")
    find(11, "((1 + 5) + 5)")
      find(16, "(((1 + 5) + 5) + 5)")
        too big
      find(33, "(((1 + 5) + 5) * 3)")
        too big
    find(18, "((1 + 5) * 3)")
      too big
  find(3, "(1 * 3)")
    find(8, "((1 * 3) + 5)")
      find(13, "(((1 * 3) + 5) + 5)")
        found!
----

The indentation suggests the depth of the call stack. The first time
`find` is called it calls itself twice to explore the solutions that start with
`(1 + 5)` and `(1 * 3)`. The first call tries to find a solution that
starts with `(1 + 5)` and, using recursion, explores _every_ solution
that yields a number less than or equal to the target number. Since
it doesn't find a solution that hits the target, it returns `null`
back to the first call. There the `||` operator causes the call that
explores `(1 * 3)` to happen. This search has more luck because its
first recursive call, through yet _another_ recursive call, hits upon
the target number, 13. This innermost recursive call returns a string,
and each of the `||` operators in the intermediate calls pass that
string along, ultimately returning our solution.

== Growing functions ==

(((function,definition)))There are two more or less natural ways for
functions to be introduced into programs.

(((repetition)))The first is that you find yourself writing very
similar code multiple times. We want to avoid doing that since having
more code means more space for mistakes to hide and more material to
read for people trying to understand the program. So we take the
repeated functionality, find a good name for it, and put it into a
function.

The second way is that you find you need some functionality that you
haven't written yet and that sounds like it deserves its own function.
You'll start by naming the function, and you'll then write its body.
You might even start writing code that uses the function before you
actually define the function itself.

(((function,naming)))(((variable,naming)))How difficult it is to find
a good name for a function is a good indication of how clear a concept
it is that you're trying to wrap. Let's go through an example.

(((farm example)))We want to write a program that prints two numbers,
the numbers of cows and chickens on a farm, with the words `Cows` and
`Chickens` after them, and zeros padded before both numbers so that
they are always three digits long.

----
007 Cows
011 Chickens
----

That clearly asks for a function of two arguments. Let's get coding.

[source,javascript]
----
function printFarmInventory(cows, chickens) {
  var cowString = String(cows);
  while (cowString.length < 3)
    cowString = "0" + cowString;
  console.log(cowString + " Cows");
  var chickenString = String(chickens);
  while (chickenString.length < 3)
    chickenString = "0" + chickenString;
  console.log(chickenString + " Chickens");
}
printFarmInventory(7, 11);
----

(((length property,for string)))(((while loop)))Adding `.length`
after a string value will give us the length of that string. Thus, the
`while` loops keep adding zeros in front of the number strings until
they are at least three characters long.

Mission accomplished! But just as we are about to send the farmer the
code (along with a hefty invoice, of course), he calls and tells us
he's also started keeping pigs, and couldn't we please extend the
software to also print pigs?

(((copy-paste programming)))We sure can. But just as we're in the
process of copying and pasting those four lines one more time, we stop
and reconsider. There has to be a better way. Here's a first attempt:

[source,javascript]
----
function printZeroPaddedWithLabel(number, label) {
  var numberString = String(number);
  while (numberString.length < 3)
    numberString = "0" + numberString;
  console.log(numberString + " " + label);
}

function printFarmInventory(cows, chickens, pigs) {
  printZeroPaddedWithLabel(cows, "Cows");
  printZeroPaddedWithLabel(chickens, "Chickens");
  printZeroPaddedWithLabel(pigs, "Pigs");
}

printFarmInventory(7, 11, 3);
----

(((function,naming)))It works! But that name,
`printZeroPaddedWithLabel`, is a little awkward. It conflates three
things—printing, zero-padding, and adding a label—into a single
function.

(((zeroPad function)))Instead of lifting out the repeated part of our
program wholesale, let's try to pick out a single _concept_.

[source,javascript]
----
function zeroPad(number, width) {
  var string = String(number);
  while (string.length < width)
    string = "0" + string;
  return string;
}

function printFarmInventory(cows, chickens, pigs) {
  console.log(zeroPad(cows, 3) + " Cows");
  console.log(zeroPad(chickens, 3) + " Chickens");
  console.log(zeroPad(pigs, 3) + " Pigs");
}

printFarmInventory(7, 16, 3);
----

(((readability)))(((pure function)))A function with a nice, obvious
name like `zeroPad` makes it easier for someone who reads the code to
figure out what it does. And it is useful in more situations than just
this specific program. For example, you could use it to help print
nicely aligned tables of numbers.

(((interface,design)))How smart and versatile should our function be?
We could write anything from a terribly simple function that simply
pads a number so that it's three characters wide to a complicated
generalized number-formatting system that handles fractional numbers,
negative numbers, alignment of dots, padding with different
characters, and so on.

A useful principle is not to add cleverness unless you are absolutely
sure you're going to need it. It can be tempting to write general
“((framework))s” for every little bit of functionality you come
across. Resist that urge. You won't get any real work done, and you'll
end up writing a lot of code that no one will ever use.

[[pure]]
== Functions and side effects ==

(((side effect)))(((pure function)))(((function,purity)))Functions can
be roughly divided into those that are called for their side effects
and those that are called for their return value. (Though it is
definitely also possible to have both side effects and return a
value.)

(((reuse)))The first helper function in the ((farm example)),
`printZeroPaddedWithLabel`, is called for its side effect: it prints a
line. The second version, `zeroPad`, is called for its return value.
It is no coincidence that the second is useful in more situations than
the first. Functions that create values are easier to combine in new
ways than functions that directly perform side effects.

(((substitution)))A _pure_ function is a specific kind of
value-producing function that not only has no side effects but also
doesn't rely on side effects from other code—for example, it doesn't
read global variables that are occasionally changed by other code. A
pure function has the pleasant property that, when called with the
same arguments, it always produces the same value (and doesn't do
anything else). This makes it easy to reason about. A call to such a
function can be mentally substituted by its result, without changing
the meaning of the code. When you are not sure that a pure function is
working correctly, you can test it by simply calling it, and know that
if it works in that context, it will work in any context. Nonpure
functions might return different values based on all kinds of factors
and have side effects that might be hard to test and think about.

(((optimization)))(((console.log)))Still, there's no need to feel bad
when writing functions that are not pure or to wage a holy war to
purge them from your code. Side effects are often useful. There'd be
no way to write a pure version of `console.log`, for example, and
`console.log` is certainly useful. Some operations are also easier to
express in an efficient way when we use side effects, so computing
speed can be a reason to avoid purity.

== Summary ==

This chapter taught you how to write your own functions. The
`function` keyword, when used as an expression, can create a function
value. When used as a statement, it can be used to declare a variable
and give it a function as its value.

[source,javascript]
----
// Create a function value f
var f = function(a) {
  console.log(a + 2);
};

// Declare g to be a function
function g(a, b) {
  return a * b * 3.5;
}
----

A key aspect in understanding functions is understanding local scopes.
Parameters and variables declared inside a function are local to the
function, re-created every time the function is called, and not visible
from the outside. Functions declared inside another function have
access to the outer function's local scope.

Separating the tasks your program performs into different
functions is helpful. You won't have to repeat yourself as much, and
functions can make a program more readable by grouping code into
conceptual chunks, in the same way that chapters and sections help
organize regular text.

== Exercises ==

=== Minimum ===

(((Math object)))(((minimum (exercise))))(((Math.min
function)))(((minimum)))The
link:02_program_structure.html#return_values[previous chapter]
introduced the standard function `Math.min` that returns its smallest
argument. We can do that ourselves now. Write a function `min` that
takes two arguments and returns their minimum.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Your code here.

console.log(min(0, 10));
// → 0
console.log(min(0, -10));
// → -10
----
endif::interactive_target[]

!!hint!!

(((minimum (exercise))))If you have trouble putting braces and
parentheses in the right place to get a valid function definition,
start by copying one of the examples in this chapter and modifying it.

(((return keyword)))A function may contain multiple `return`
statements.

!!hint!!

=== Recursion ===

(((recursion)))(((isEven (exercise))))(((even number)))We've seen
that `%` (the remainder operator) can be used to test whether a number
is even or odd by using `% 2` to check whether it's divisible by two.
Here's another way to define whether a positive whole number is even
or odd:

- Zero is even.

- One is odd.

- For any other number _N_, its evenness is the same as _N_ - 2.

Define a recursive function `isEven` corresponding to this
description. The function should accept a `number` parameter and
return a Boolean.

(((stack overflow)))Test it on 50 and 75. See how it behaves on -1.
Why? Can you think of a way to fix this?

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Your code here.

console.log(isEven(50));
// → true
console.log(isEven(75));
// → false
console.log(isEven(-1));
// → ??
----
endif::interactive_target[]

!!hint!!

(((isEven (exercise))))(((if keyword,chaining)))(((recursion)))Your
function will likely look somewhat similar to the inner `find`
function in the recursive `findSolution`
link:03_functions.html#recursive_puzzle[example] in this chapter, with
an `if`/`else if`/`else` chain that tests which of the three cases
applies. The final `else`, corresponding to the third case, makes the
recursive call. Each of the branches should contain a `return`
statement or in some other way arrange for a specific value to be
returned.

(((stack overflow)))When given a negative number, the function will
recurse again and again, passing itself an ever more negative number,
thus getting further and further away from returning a result. It will
eventually run out of stack space and abort.

!!hint!!

=== Bean counting ===

(((bean counting (exercise))))(((charAt
method)))(((string,indexing)))(((zero-based counting)))You can get the
Nth character, or letter, from a string by writing
`"string".charAt(N)`, similar to how you get its length with
`"s".length`. The returned value will be a string containing only one
character (for example, `"b"`). The first character has position zero,
which causes the last one to be found at position `string.length - 1`.
In other words, a two-character string has length 2, and its
characters have positions 0 and 1.

Write a function `countBs` that takes a string as its only argument
and returns a number that indicates how many uppercase “B” characters
are in the string.

Next, write a function called `countChar` that behaves like `countBs`,
except it takes a second argument that indicates the character that is
to be counted (rather than counting only uppercase “B” characters).
Rewrite `countBs` to make use of this new function.

ifdef::interactive_target[]

// test: no

[source,javascript]
----
// Your code here.

console.log(countBs("BBC"));
// → 2
console.log(countChar("kakkerlak", "k"));
// → 4
----
endif::interactive_target[]

!!hint!!

(((bean counting (exercise))))(((length property,for
string)))(((counter variable)))A ((loop)) in your function will have
to look at every character in the string by running an index from zero
to one below its length (`< string.length`). If the character at the
current position is the same as the one the function is looking for,
it adds 1 to a counter variable. Once the loop has finished, the
counter can be returned.

(((local variable)))Take care to make all the variables used in the
function _local_ to the function by using the `var` keyword.

!!hint!!
